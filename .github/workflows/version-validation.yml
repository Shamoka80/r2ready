name: Version Validation

on:
  push:
    tags:
      - 'v*.*.*'
  release:
    types: [published, prereleased]
  pull_request:
    branches:
      - main

jobs:
  version-consistency-check:
    name: Check Version Consistency
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify package.json versions match
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            try {
              const rootPackage = JSON.parse(fs.readFileSync('package.json', 'utf8'));
              const serverPackage = JSON.parse(fs.readFileSync('server/package.json', 'utf8'));
              const clientPackage = JSON.parse(fs.readFileSync('client/package.json', 'utf8'));
              
              const rootVersion = rootPackage.version;
              const serverVersion = serverPackage.version;
              const clientVersion = clientPackage.version;
              
              console.log(`Root version: ${rootVersion}`);
              console.log(`Server version: ${serverVersion}`);
              console.log(`Client version: ${clientVersion}`);
              
              if (rootVersion !== serverVersion || rootVersion !== clientVersion) {
                const message = `⚠️ **Version Mismatch Detected**\n\n` +
                  `Version numbers are not consistent across package.json files:\n\n` +
                  `- Root: \`${rootVersion}\`\n` +
                  `- Server: \`${serverVersion}\`\n` +
                  `- Client: \`${clientVersion}\`\n\n` +
                  `**Recommendation:** Update all package.json files to have the same version number.\n\n` +
                  `\`\`\`bash\n` +
                  `# Update all packages to the same version\n` +
                  `npm version ${rootVersion} --no-git-tag-version\n` +
                  `cd server && npm version ${rootVersion} --no-git-tag-version\n` +
                  `cd ../client && npm version ${rootVersion} --no-git-tag-version\n` +
                  `\`\`\``;
                
                core.warning(message);
              } else {
                console.log('✅ All package.json versions are consistent');
              }
            } catch (error) {
              core.warning(`Could not verify version consistency: ${error.message}`);
            }
            
            // Always succeed - this is informational
            console.log('✅ Version consistency check completed');

  tag-version-check:
    name: Validate Tag vs Package Version
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: startsWith(github.ref, 'refs/tags/v')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Compare tag version with package.json
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            try {
              const tagName = context.ref.replace('refs/tags/', '');
              const tagVersion = tagName.replace(/^v/, '');
              
              const rootPackage = JSON.parse(fs.readFileSync('package.json', 'utf8'));
              const packageVersion = rootPackage.version;
            
            console.log(`Git tag version: ${tagVersion} (from ${tagName})`);
            console.log(`package.json version: ${packageVersion}`);
            
            if (tagVersion !== packageVersion) {
              const message = `⚠️ **Tag and Package Version Mismatch**\n\n` +
                `The git tag version does not match the package.json version:\n\n` +
                `- Git tag: \`${tagName}\` (version: \`${tagVersion}\`)\n` +
                `- package.json: \`${packageVersion}\`\n\n` +
                `**Recommendation:**\n` +
                `1. Update package.json to version \`${tagVersion}\`, OR\n` +
                `2. Delete the tag and create a new one matching \`v${packageVersion}\`\n\n` +
                `This is informational - workflow will continue.`;
              
              core.warning(message);
            } else {
              console.log('✅ Tag version matches package.json version');
            }
            
            // Always succeed - this is informational
            console.log('✅ Tag version check completed');
            } catch (error) {
              core.warning(`Tag version check error: ${error.message}`);
              console.log('✅ Tag version check completed (with errors)');
            }

  semantic-version-format-check:
    name: Validate Semantic Version Format
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate version follows semantic versioning
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            try {
              const rootPackage = JSON.parse(fs.readFileSync('package.json', 'utf8'));
              const version = rootPackage.version;
              
              const semverRegex = /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-(alpha|beta|rc)\.(0|[1-9]\d*))?(?:\+[\w.-]+)?$/;
              
              console.log(`Validating version: ${version}`);
              
              if (!semverRegex.test(version)) {
                const message = `⚠️ **Invalid Semantic Version Format**\n\n` +
                  `The version \`${version}\` does not follow semantic versioning format.\n\n` +
                  `**Valid Formats:**\n` +
                  `- Production: \`MAJOR.MINOR.PATCH\` (e.g., \`1.0.0\`, \`2.3.4\`)\n` +
                  `- Alpha: \`MAJOR.MINOR.PATCH-alpha.N\` (e.g., \`2.0.0-alpha.1\`)\n` +
                  `- Beta: \`MAJOR.MINOR.PATCH-beta.N\` (e.g., \`2.0.0-beta.1\`)\n` +
                  `- RC: \`MAJOR.MINOR.PATCH-rc.N\` (e.g., \`2.0.0-rc.1\`)\n\n` +
                  `**Rules:**\n` +
                  `- MAJOR, MINOR, PATCH must be non-negative integers\n` +
                  `- No leading zeros (use \`1.0.0\`, not \`1.00.0\`)\n` +
                  `- Prerelease identifiers: alpha, beta, or rc only\n` +
                  `- Prerelease number must be a non-negative integer\n\n` +
                  `**Examples:**\n` +
                  `✅ Valid: \`1.0.0\`, \`2.3.4\`, \`1.0.0-alpha.1\`, \`3.2.1-beta.2\`, \`1.5.0-rc.1\`\n` +
                  `❌ Invalid: \`v1.0.0\`, \`1.0\`, \`1.0.0-preview.1\`, \`01.0.0\`\n\n` +
                  `**Action Required:** Update version in package.json to follow semantic versioning format.`;
                
                core.warning(message);
              } else {
                console.log('✅ Version follows semantic versioning format');
                
                const parts = version.match(semverRegex);
                const major = parts[1];
                const minor = parts[2];
                const patch = parts[3];
                const prerelease = parts[4] ? `${parts[4]}.${parts[5]}` : 'none';
                
                console.log(`  MAJOR: ${major}`);
                console.log(`  MINOR: ${minor}`);
                console.log(`  PATCH: ${patch}`);
                console.log(`  Prerelease: ${prerelease}`);
              }
            } catch (error) {
              core.warning(`Could not validate version format: ${error.message}`);
            }
            
            // Always succeed - this is informational
            console.log('✅ Semantic version format check completed');

  version-increment-validation:
    name: Validate Version Increment
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Checkout main branch
        run: git fetch origin main:main

      - name: Compare versions and validate increment
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            
            try {
              const prPackage = JSON.parse(fs.readFileSync('package.json', 'utf8'));
              const prVersion = prPackage.version;
              
              try {
                execSync('git fetch origin main:main 2>&1', { stdio: 'pipe' });
                execSync('git checkout main -- package.json 2>&1', { stdio: 'pipe' });
                const mainPackage = JSON.parse(fs.readFileSync('package.json', 'utf8'));
                const mainVersion = mainPackage.version;
                execSync('git checkout HEAD -- package.json 2>&1', { stdio: 'pipe' });
                
                console.log(`Main branch version: ${mainVersion}`);
                console.log(`PR branch version: ${prVersion}`);
                
                if (prVersion === mainVersion) {
                  const message = `⚠️ **Version Not Updated**\n\n` +
                    `The version in package.json (${prVersion}) is the same as the main branch.\n\n` +
                    `**Recommendation:** Increment the version according to the type of changes:\n` +
                    `- Breaking changes → Increment MAJOR\n` +
                    `- New features → Increment MINOR\n` +
                    `- Bug fixes → Increment PATCH\n\n` +
                    `This is informational - PR can still be merged.`;
                  
                  core.warning(message);
                  return;
                }
                
                const parseVersion = (v) => {
                  const match = v.match(/^(\d+)\.(\d+)\.(\d+)(?:-.*)?$/);
                  if (!match) return null;
                  return { major: parseInt(match[1]), minor: parseInt(match[2]), patch: parseInt(match[3]) };
                };
                
                const main = parseVersion(mainVersion);
                const pr = parseVersion(prVersion);
                
                if (!main || !pr) {
                  console.log('⚠️ Could not parse version numbers for comparison');
                  return;
                }
                
                const isValidIncrement = (
                  pr.major > main.major ||
                  (pr.major === main.major && pr.minor > main.minor) ||
                  (pr.major === main.major && pr.minor === main.minor && pr.patch > main.patch)
                );
                
                if (!isValidIncrement) {
                  const message = `⚠️ **Version Increment Recommendation**\n\n` +
                    `The PR version (${prVersion}) should be greater than the main branch version (${mainVersion}).\n\n` +
                    `This is informational - PR can still be merged.`;
                  
                  core.warning(message);
                  return;
                }
                
                console.log('✅ Version increment is valid');
              } catch (error) {
                console.log(`⚠️ Could not compare with main branch: ${error.message}`);
                console.log('Skipping version increment validation');
              }
            } catch (error) {
              core.warning(`Could not validate version increment: ${error.message}`);
            }
            
            // Always succeed - this is informational
            console.log('✅ Version increment validation completed');

  changelog-validation:
    name: Validate CHANGELOG Update
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check CHANGELOG.md updated
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            
            try {
              if (!fs.existsSync('CHANGELOG.md')) {
                console.log('ℹ️ CHANGELOG.md not found - skipping validation');
                return;
              }
              
              try {
                const changedFiles = execSync('git diff --name-only origin/main...HEAD 2>&1', { stdio: 'pipe' }).toString().split('\n');
                const changelogModified = changedFiles.includes('CHANGELOG.md');
                
                const prPackage = JSON.parse(fs.readFileSync('package.json', 'utf8'));
                const prVersion = prPackage.version;
                
                try {
                  execSync('git fetch origin main:main 2>&1', { stdio: 'pipe' });
                  execSync('git checkout main -- package.json 2>&1', { stdio: 'pipe' });
                  const mainPackage = JSON.parse(fs.readFileSync('package.json', 'utf8'));
                  const mainVersion = mainPackage.version;
                  execSync('git checkout HEAD -- package.json 2>&1', { stdio: 'pipe' });
                  
                  const versionChanged = prVersion !== mainVersion;
                  
                  if (versionChanged && !changelogModified) {
                    const message = `⚠️ **CHANGELOG.md Not Updated**\n\n` +
                      `The version changed from ${mainVersion} to ${prVersion}, but CHANGELOG.md was not updated.\n\n` +
                      `**Recommendation:** Update CHANGELOG.md with the new version and changes.\n\n` +
                      `This is informational - PR can still be merged.`;
                    
                    core.warning(message);
                    return;
                  }
                  
                  if (versionChanged && changelogModified) {
                    const changelog = fs.readFileSync('CHANGELOG.md', 'utf8');
                    const versionPattern = new RegExp(`##\\s*\\[?${prVersion.replace(/\./g, '\\.')}\\]?`, 'i');
                    
                    if (!versionPattern.test(changelog)) {
                      core.warning(`CHANGELOG.md was modified, but version ${prVersion} was not found.`);
                    } else {
                      console.log(`✅ CHANGELOG.md updated with version ${prVersion}`);
                    }
                  }
                  
                  if (!versionChanged) {
                    console.log('ℹ️ Version not changed, skipping CHANGELOG validation');
                  }
                } catch (error) {
                  console.log(`⚠️ Could not compare with main branch: ${error.message}`);
                }
              } catch (error) {
                console.log(`⚠️ Could not check CHANGELOG: ${error.message}`);
              }
            } catch (error) {
              core.warning(`Could not validate CHANGELOG: ${error.message}`);
            }
            
            // Always succeed - this is informational
            console.log('✅ CHANGELOG validation completed');
