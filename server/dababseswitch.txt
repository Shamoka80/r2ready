# Database Switch: Neon to Local PostgreSQL

**Date:** Current Session  
**Purpose:** Switch from Neon (serverless PostgreSQL) to local PostgreSQL for local development

---

## Quick Reference

### Files Modified (10 total)

| File | Change Type | Revert Required |
|------|-------------|----------------|
| `server/db.ts` | Database driver + dotenv + fixes | ✅ Yes |
| `server/wake-db.js` | Database driver | ✅ Yes |
| `scripts/seed-test-users.ts` | Database driver | ✅ Yes |
| `scripts/seed-demo-tenants.ts` | Database driver | ✅ Yes |
| `scripts/purge-users.ts` | Database driver | ✅ Yes |
| `scripts/migrate-database.ts` | Database driver | ✅ Yes |
| `scripts/cleanup-test-data.ts` | Database driver | ✅ Yes |
| `server/routes/auth.ts` | Syntax fixes (unrelated) | ❌ No (pre-existing bugs) |
| `server/utils/schemaValidator.ts` | Error handling fix (PostgreSQL compatibility) | ⚠️ Optional (improvement, but may be needed) |
| `server/services/dashboardAnalyticsService.ts` | Dashboard KPIs fix (PostgreSQL compatibility) | ⚠️ Optional (prevents crashes, recommended to keep) |

### Change Pattern (All Database Files)

**BEFORE (Neon):**
```typescript
import { neon, neonConfig } from '@neondatabase/serverless';
import { drizzle } from 'drizzle-orm/neon-http';
const sql = neon(process.env.DATABASE_URL);
const db = drizzle(sql, { schema });
```

**AFTER (PostgreSQL):**
```typescript
import postgres from 'postgres';
import { drizzle } from 'drizzle-orm/postgres-js';
const client = postgres(process.env.DATABASE_URL);
const db = drizzle(client, { schema });
```

---

## Detailed Changes by File

### 1. `server/db.ts` - Main Database Connection

#### A. Environment Variable Loading (ADDED - Keep on revert)
**Location:** Top of file (before imports)

**Code Added:**
```typescript
// Load environment variables from server/.env file FIRST
import { config } from 'dotenv';
import { fileURLToPath } from 'url';
import path from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Load .env file from server directory before accessing process.env
config({ path: path.join(__dirname, '.env') });
```

**Revert:** ❌ KEEP THIS - Useful for both Neon and PostgreSQL

---

#### B. Imports Changed
**BEFORE:**
```typescript
import { neon, neonConfig } from '@neondatabase/serverless';
import { drizzle } from 'drizzle-orm/neon-http';
```

**AFTER:**
```typescript
import postgres from 'postgres';
import { drizzle } from 'drizzle-orm/postgres-js';
```

**Revert:** Change back to Neon imports

---

#### C. Connection Setup Changed
**BEFORE:**
```typescript
neonConfig.pipelineConnect = 'password';
const sql = neon(dbUrl);
export const db = drizzle(sql as any, { schema });
export { sql };
```

**AFTER:**
```typescript
const client = postgres(dbUrl);
const sql = client; // Create local reference for use in this module
export const db = drizzle(client, { schema });
export { sql };
```

**Revert:** 
- Remove `const sql = client;` line
- Change `const client = postgres(dbUrl)` to `const sql = neon(dbUrl)`
- Add `neonConfig.pipelineConnect = 'password';` after imports
- Change `drizzle(client, { schema })` to `drizzle(sql as any, { schema })`

---

#### D. executeQuery Function Changed
**BEFORE:** Used Neon's tagged template syntax with complex parameter binding

**AFTER:**
```typescript
export async function executeQuery(query: string, params: any[] = []) {
  if (params.length === 0) {
    const rows = await sql.unsafe(query);
    return { rows, rowCount: rows.length };
  }
  const rows = await sql.unsafe(query, params);
  return { rows, rowCount: rows.length };
}
```

**Revert:** Restore original Neon-specific parameter binding logic

---

### 2. `server/wake-db.js` - Database Wake Script

**BEFORE:**
```javascript
import { neon } from '@neondatabase/serverless';
const sql = neon(process.env.DATABASE_URL);
const result = await sql`SELECT NOW() as current_time, 'Database is awake!' as message`;
```

**AFTER:**
```javascript
import postgres from 'postgres';
const client = postgres(process.env.DATABASE_URL);
const result = await client`SELECT NOW() as current_time, 'Database is connected!' as message`;
await client.end(); // Close connection after use
```

**Revert:**
- Change import back to Neon
- Change `const client = postgres(...)` to `const sql = neon(...)`
- Change `client\`...\`` to `sql\`...\``
- Remove `await client.end();`

---

### 3. `scripts/seed-test-users.ts` - Test User Seeding Script

**BEFORE:**
```typescript
import { neon } from "@neondatabase/serverless";
import { drizzle } from "drizzle-orm/neon-http";
const connection = neon(process.env.DATABASE_URL);
const db = drizzle(connection, { schema });
```

**AFTER:**
```typescript
import postgres from "postgres";
import { drizzle } from "drizzle-orm/postgres-js";
const client = postgres(process.env.DATABASE_URL);
const db = drizzle(client, { schema });
```

**Revert:** Apply reverse pattern (same as file #2)

---

### 4. `scripts/seed-demo-tenants.ts` - Demo Tenant Seeding Script

**BEFORE:**
```typescript
import { neon } from "@neondatabase/serverless";
import { drizzle } from "drizzle-orm/neon-http";
const connection = neon(process.env.DATABASE_URL);
const db = drizzle(connection, { schema });
```

**AFTER:**
```typescript
import postgres from "postgres";
import { drizzle } from "drizzle-orm/postgres-js";
const client = postgres(process.env.DATABASE_URL);
const db = drizzle(client, { schema });
```

**Revert:** Apply reverse pattern (same as file #3)

---

### 5. `scripts/purge-users.ts` - User Purge Script

**BEFORE:**
```typescript
import { neon } from "@neondatabase/serverless";
import { drizzle } from "drizzle-orm/neon-http";
const connection = neon(process.env.DATABASE_URL);
this.db = drizzle(connection);
```

**AFTER:**
```typescript
import postgres from "postgres";
import { drizzle } from "drizzle-orm/postgres-js";
this.client = postgres(process.env.DATABASE_URL);
this.db = drizzle(this.client);
```

**Revert:** Apply reverse pattern (same as file #3)

---

### 6. `scripts/migrate-database.ts` - Database Migration Script

**BEFORE:**
```typescript
import { drizzle } from 'drizzle-orm/neon-http';
import { migrate } from 'drizzle-orm/neon-http/migrator';
import { neon } from '@neondatabase/serverless';
const sql = neon(process.env.DATABASE_URL);
const db = drizzle(sql);
await migrate(db, { migrationsFolder: './migrations' });
```

**AFTER:**
```typescript
import { drizzle } from 'drizzle-orm/postgres-js';
import { migrate } from 'drizzle-orm/postgres-js/migrator';
import postgres from 'postgres';
const client = postgres(process.env.DATABASE_URL);
const db = drizzle(client);
await migrate(db, { migrationsFolder: './migrations' });
await client.end(); // Close connection after migrations
```

**Revert:**
- Change imports back to `neon-http`
- Change `const client = postgres(...)` to `const sql = neon(...)`
- Change `drizzle(client)` to `drizzle(sql)`
- Remove `await client.end();`

---

### 7. `scripts/cleanup-test-data.ts` - Test Data Cleanup Script

**BEFORE:**
```typescript
import { drizzle } from 'drizzle-orm/neon-http';
import { neon } from '@neondatabase/serverless';
const connection = neon(process.env.DATABASE_URL);
this.db = drizzle(connection);
```

**AFTER:**
```typescript
import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';
this.client = postgres(process.env.DATABASE_URL);
this.db = drizzle(this.client);
```

**Revert:** Apply reverse pattern (same as file #5)

---

### 8. `server/routes/auth.ts` - Syntax Error Fixes (Pre-existing bugs)

**Note:** These fixes are unrelated to the database switch but were necessary for the app to run.

**Changes:** Removed 5 orphaned code fragments at lines:
- 1482-1483: `userId: req.user!.id });`
- 1593-1594: `recoveryMode: isStuckInIncompleteState });`
- 1689-1690: `setupStatus: updateData.setupStatus || user.setupStatus });`
- 1806-1807: `setupStatus: updateData.setupStatus || user.setupStatus });` (duplicate)
- 1993-1997: Orphaned object literal

**Revert:** ❌ Do NOT revert - these were pre-existing bugs

---

### 9. `server/utils/schemaValidator.ts` - Error Handling Fix

**BEFORE:**
```typescript
const tableExistsQuery = await db.execute(sql`...`);
const tableExists = (tableExistsQuery.rows[0] as any)?.exists ?? false;
```

**AFTER:**
```typescript
let tableExistsQuery;
try {
  tableExistsQuery = await db.execute(sql`...`);
} catch (queryError) {
  const errorMsg = queryError instanceof Error ? queryError.message : String(queryError);
  errors.push(`❌ Failed to check if table '${tableName}' exists: ${errorMsg}`);
  continue;
}

let tableExists = false;
if (tableExistsQuery && tableExistsQuery.rows && Array.isArray(tableExistsQuery.rows) && tableExistsQuery.rows.length > 0) {
  tableExists = (tableExistsQuery.rows[0] as any)?.exists ?? false;
} else if (Array.isArray(tableExistsQuery) && tableExistsQuery.length > 0) {
  tableExists = (tableExistsQuery[0] as any)?.exists ?? false;
} else {
  warnings.push(`⚠️  Could not determine if table '${tableName}' exists - unexpected result structure`);
  continue;
}
```

**Also fixed columns query:**
```typescript
// BEFORE:
const columnsQuery = await db.execute(sql`...`);
const actualColumns = columnsQuery.rows as Array<{...}>;

// AFTER:
let columnsQuery;
try {
  columnsQuery = await db.execute(sql`...`);
} catch (queryError) {
  const errorMsg = queryError instanceof Error ? queryError.message : String(queryError);
  errors.push(`❌ Failed to get columns for table '${tableName}': ${errorMsg}`);
  continue;
}

let actualColumns: Array<{...}> = [];
if (columnsQuery && columnsQuery.rows && Array.isArray(columnsQuery.rows)) {
  actualColumns = columnsQuery.rows as Array<{...}>;
} else if (Array.isArray(columnsQuery)) {
  actualColumns = columnsQuery as Array<{...}>;
} else {
  warnings.push(`⚠️  Could not get columns for table '${tableName}' - unexpected result structure`);
  continue;
}
```

**Revert:** ⚠️ Optional - This is an improvement that works with both Neon and PostgreSQL, but may be needed for PostgreSQL compatibility

---

## Revert Instructions (Step-by-Step)

### Step 1: Revert `server/db.ts`

1. **KEEP** the dotenv configuration at the top (lines with `import { config } from 'dotenv'`)

2. **Change imports:**
   ```typescript
   // FROM:
   import postgres from 'postgres';
   import { drizzle } from 'drizzle-orm/postgres-js';
   
   // TO:
   import { neon, neonConfig } from '@neondatabase/serverless';
   import { drizzle } from 'drizzle-orm/neon-http';
   ```

3. **Add Neon config after imports:**
   ```typescript
   neonConfig.pipelineConnect = 'password';
   ```

4. **Change connection setup:**
   ```typescript
   // FROM:
   const client = postgres(dbUrl);
   const sql = client;
   export const db = drizzle(client, { schema });
   
   // TO:
   const sql = neon(dbUrl);
   export const db = drizzle(sql as any, { schema });
   ```

5. **Revert `executeQuery` function** to original Neon-specific parameter binding logic

---

### Step 2: Revert Script Files (Files #2-7)

For each file (`wake-db.js`, `seed-test-users.ts`, `seed-demo-tenants.ts`, `purge-users.ts`, `migrate-database.ts`, `cleanup-test-data.ts`):

1. **Change imports:**
   ```typescript
   // FROM:
   import postgres from 'postgres';
   import { drizzle } from 'drizzle-orm/postgres-js';
   // (or migrate from 'drizzle-orm/postgres-js/migrator')
   
   // TO:
   import { neon } from '@neondatabase/serverless';
   import { drizzle } from 'drizzle-orm/neon-http';
   // (or migrate from 'drizzle-orm/neon-http/migrator')
   ```

2. **Change connection:**
   ```typescript
   // FROM:
   const client = postgres(process.env.DATABASE_URL);
   const db = drizzle(client, { schema });
   
   // TO:
   const sql = neon(process.env.DATABASE_URL);
   const db = drizzle(sql, { schema });
   ```

3. **For `wake-db.js` and `migrate-database.ts`:** Remove `await client.end();` calls

4. **For `wake-db.js`:** Change `client\`...\`` to `sql\`...\``

---

### Step 3: Verify Changes

1. Check that all imports use `@neondatabase/serverless` and `drizzle-orm/neon-http`
2. Check that all connections use `neon()` instead of `postgres()`
3. Verify `neonConfig.pipelineConnect = 'password';` is in `server/db.ts`
4. Test database connection: `node server/wake-db.js`

---

## Environment Variables

**Location:** `server/.env` (must be in server directory)

**Format:**
```
DATABASE_URL=postgresql://username:password@localhost:5432/database_name
```

**Note:** The dotenv configuration in `server/db.ts` loads from `server/.env`. This works for both Neon and PostgreSQL.

---

## Dependencies

- ✅ `postgres` package (^3.4.5) - already installed
- ✅ `dotenv` package - already installed
- ⚠️ `@neondatabase/serverless` - still in package.json (unused, can be removed)

---

## Testing Checklist

After reverting:
- [ ] All imports changed back to Neon
- [ ] `neonConfig.pipelineConnect = 'password';` added to `server/db.ts`
- [ ] All `postgres()` calls changed to `neon()`
- [ ] All `drizzle-orm/postgres-js` changed to `drizzle-orm/neon-http`
- [ ] `await client.end()` calls removed from scripts
- [ ] Database connection test passes: `node server/wake-db.js`
- [ ] Application starts without errors

---

## Notes

- **Dotenv configuration:** Keep it - useful for both Neon and PostgreSQL
- **Syntax fixes in auth.ts:** Do NOT revert - these were pre-existing bugs
- **Schema validator fix:** Optional to revert - works with both drivers
- **No schema changes:** Database schema remains the same
- **No business logic changes:** Only database driver changed

---

---

### 10. `server/services/dashboardAnalyticsService.ts` - Dashboard KPIs Fix (PostgreSQL Compatibility)

**Issue:** 
- Error: `TypeError: Cannot read properties of undefined (reading '0')` at line 123
- Dashboard API `/api/dashboard/overview` returns 500
- Breaks dashboard functionality (search, notifications, quick add, profile menu)

**BEFORE:**
```typescript
const statsResult = await db.execute(sql`...`);
const stats = statsResult.rows[0]; // ❌ Fails if rows is undefined or empty

const [facilityCount] = await db.select(...); // ❌ Fails if result is empty
```

**AFTER:**
```typescript
const statsResult = await db.execute(sql`...`);

// Safe access to stats result - handle both Neon and PostgreSQL result structures
let stats: any = null;
if (statsResult && statsResult.rows && Array.isArray(statsResult.rows) && statsResult.rows.length > 0) {
  stats = statsResult.rows[0];
} else if (Array.isArray(statsResult) && statsResult.length > 0) {
  stats = statsResult[0];
}

// Safe facility count access
const facilityCountResult = await db.select(...);
const facilityCount = facilityCountResult.length > 0 ? facilityCountResult[0] : null;
```

**Revert:** ⚠️ Optional - This fix ensures compatibility with PostgreSQL result structures and prevents crashes when database returns empty results. Recommended to keep.

---

**End of Documentation**

